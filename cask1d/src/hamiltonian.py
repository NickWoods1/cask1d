import numpy as np
from density2potential.utils.math import discrete_Laplace, normalise_function


"""
Constructs the Hamiltonian, including all potentials
"""


def construct_hamiltonian(params, density, density_matrix='optional'):
    r"""
    Creates the full Hamiltonian for a given level of approximation
    """

    # Kinetic energy stencil
    hamiltonian = kinetic(params)

    # External potential generated from atomic input
    hamiltonian += np.diag(v_ext(params))

    # Hartree potential for a given density
    hamiltonian += np.diag(v_h(params, density))

    if params.method == 'dft':
        hamiltonian += np.diag(v_xc(density))
    elif params.method == 'hf':
        hamiltonian += fock_exchange(params, density_matrix)

    return hamiltonian


def construct_hamiltonian_independent(params):
    """
    Constructs the Hamiltonian for each particle without reference to other particles: H = KE + external
    """

    # Kinetic energy stencil
    hamiltonian = kinetic(params)

    # External potential generated from atomic input
    hamiltonian += np.diag(v_ext(params))

    return hamiltonian


def update_hamiltonian(params, hamiltonian_indep, density, density_matrix='optional'):
    r"""
    Updates a given independent (KE + vext) Hamiltonian with the interacting terms
    """

    hamiltonian = np.copy(hamiltonian_indep)

    # Hartree potential
    hamiltonian += np.diag(v_h(params, density))

    # XC or Fock potential
    if params.method == 'dft':
        hamiltonian += np.diag(v_xc(density))
    elif params.method == 'hf':
        hamiltonian += fock_exchange(params, density_matrix)

    return hamiltonian


def kinetic(params):
    """
    Kinetic energy for a given particle. -0.5del^2 on a grid.
    """

    return -0.5*discrete_Laplace(params)


def v_xc(density):
    """
    Exchange-correlation approximation. LDA from Entwistle 2017.
    """

    density = abs(density)

    # Check negative regions of density (imaginary v_xc)
    if np.amin(density) < 0:
        raise Exception('Negative density region exists, imaginary v_xc, exiting...')

    # Add XC potential (Entwistle 2017)
    v_xc = (-1.24 + 2.1*density - 1.7*density**2)*density**0.61

    return v_xc


def v_h(params, density):
    r"""
    Hartree potential for a given density
    """

    # Add Hartree potential
    v_h = np.zeros(params.Nspace)
    for i in range(0,params.Nspace):
        for j in range(0,params.Nspace):
            v_h[i] += density[j] / (abs(params.grid[i] - params.grid[j]) + params.soft)

    v_h *= params.dx

    return v_h


def v_ext(params):
    r"""
    Constructs the external potential generated by atoms
    """

    if not params.manual_v_ext:
        i = 0
        v_ext = np.zeros(params.Nspace)
        while i < params.num_atoms:

            # Define the charge on an atom and place a Coulomb potential at that position
            charge = params.element_charges[params.species[i]]
            v_ext += coulomb(params.Nspace, params.grid, charge, params.position[i], params.soft)

            i += 1
    elif params.manual_v_ext:
        v_ext = params.v_ext

    return v_ext


def fock_exchange(params, density_matrix):
    r"""
    Matrix elements of the Fock operator in delta function basis
    """

    # Add Fock term
    fock = np.zeros((params.Nspace,params.Nspace))
    for i in range(0,params.Nspace):
        for j in range(0,params.Nspace):
            fock[i,j] -= density_matrix[i,j] / (abs(params.grid[i] - params.grid[j]) + params.soft)

    fock *= params.dx

    return fock


def coulomb(Nspace, grid, charge, position, soft):
    r"""
    Creates a softened Coulomb potential at a given atomic position scaled with atomic
    charge (+ve int)
    """

    potential = np.zeros(Nspace)

    for i in range(0,Nspace):
        potential[i] = -charge / (abs(grid[i] - position) + soft)

    return potential


def evaluate_energy_functional(params, wavefunctions_ks, density, dmatrix='optional'):
    r"""
    Evaluates the KS energy functional E[n] for a given density + orbitals
    """

    # Kinetic energy
    kinetic_energy = 0
    laplace = discrete_Laplace(params)
    for i in range(0,params.num_particles):
        del_sq_phi = np.dot(laplace,wavefunctions_ks[:,i])
        kinetic_energy += np.sum(np.conj(wavefunctions_ks[:,i])*del_sq_phi)

    kinetic_energy *= -0.5*params.dx

    # Hartree energy
    hartree_pot = v_h(params, density)
    hartree_energy = np.sum(density*hartree_pot)*params.dx

    # External
    external_pot = v_ext(params)
    external_energy = np.sum(density*external_pot)*params.dx

    if params.method == 'dft':
        # XC energy
        xc_pot = v_xc(density)
        xc_energy = np.sum(density*xc_pot)*params.dx

        total_energy = kinetic_energy + hartree_energy + external_energy + xc_energy

    elif params.method == 'hf':
        # Exchange energy
        exchange_energy = 0
        for i in range(0,params.Nspace):
            for j in range(0,params.Nspace):
                exchange_energy -= dmatrix[i,j]**2 / (abs(params.grid[i] - params.grid[j]) + params.soft)

        exchange_energy *= params.dx**2
        total_energy = kinetic_energy + hartree_energy + external_energy + exchange_energy

    else:
        # Hartree energy
        total_energy = kinetic_energy + hartree_energy + external_energy

    return total_energy
