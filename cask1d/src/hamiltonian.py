import numpy as np
from density2potential.utils.math import discrete_Laplace, normalise_function
import matplotlib.pyplot as plt

"""
Constructs the Hamiltonian, including all potentials
"""


def construct_hamiltonian(params, density, density_matrix='optional'):

    # Kinetic energy stencil
    hamiltonian = kinetic(params)

    # External potential generated from atomic input
    hamiltonian += np.diag(v_ext(params))

    # Hartree potential for a given density
    hamiltonian += np.diag(v_h(params, density))

    if params.method == 'dft':
        hamiltonian += np.diag(v_xc(density))
    elif params.method == 'hf':
        hamiltonian += fock_exchange(params, density_matrix)

    return hamiltonian


def kinetic(params):

    return -0.5*discrete_Laplace(params)


def v_xc(density):

    # Check negative regions of density (imaginary v_xc)
    if np.amin(density) < 0:
        raise Exception('Negative density region exists, imaginary v_xc, exiting...')

    # Add XC potential (Entwistle 2017)
    v_xc = (-1.24 + 2.1*density - 1.7*density**2)*density**0.61

    return v_xc


def v_h(params, density):
    r"""
    Hartree potential for a given density
    """
    # Add Hartree potential
    v_h = np.zeros(params.Nspace)
    for i in range(0,params.Nspace):
        for j in range(0,params.Nspace):
            v_h[i] += density[j] / (abs(params.grid[i] - params.grid[j]) + params.soft)

    v_h *= params.dx

    return v_h


def v_ext(params):
    r"""
    Constructs the external potential generated by atoms
    """

    i = 0
    v_ext = np.zeros(params.Nspace)
    while i < params.num_atoms:

        # Define the charge on an atom and place a Coulomb potential at that position
        charge = params.element_charges[params.species[i]]
        v_ext += coulomb(params.Nspace, params.grid, charge, params.position[i], params.soft)

        i += 1

    return v_ext


def fock_exchange(params, density_matrix):
    r"""
    Matrix elements of the Fock operator in delta function basis
    """

    # Add Fock term
    fock = np.zeros((params.Nspace,params.Nspace))
    for i in range(0,params.Nspace_dft):
        for j in range(0,params.Nspace_dft):
            fock[i,j] += density_matrix[i,j] / (abs(params.grid_dft[i] - params.grid_dft[j]) + params.soft)

    return fock


def coulomb(Nspace, grid, charge, position, soft):
    r"""
    Creates a softened Coulomb potential at a given atomic position scaled with atomic
    charge (+ve int)
    """

    potential = np.zeros(Nspace)

    for i in range(0,Nspace):
        potential[i] = -charge / (abs(grid[i] - position) + soft)

    return potential

